;	DAZZLER SNAKE FOR THE CROMEMCO DAZZLER
;	2024 Aron Hoekstra aka nullvalue
;	nullvalue@gmail.com
;	Version 1.1

	TITLE	SNAKE FOR DAZZLER GRAPHICS
	NAME	SNAKE
;
;	DEFINITION OF GRAPHICS PACKAGE ENTRY POINTS
;
	EXTRN	INITG,PAGE,CURSOR,DOT,LINE,CHAR,ANIMAT
	EXTRN	CYCLE,PAUSE,AREA,STRING
;
;	DEFINITION OF STANDARD COLORS, RESOLUTIONS, AND TIMES FOR PAUSE
;
CPM:	EQU	0		;CONDITIONAL ASSEMBLY TO BUILD FOR CDOS OR CP/M. 
				;  CPM=0 BUILD FOR CDOS
				;  CPM=1 BUILD FOR CPM

BLACK:	EQU	10H
RED:	EQU	11H
GREEN:	EQU	12H
YELLOW:	EQU	13H
BLUE:	EQU	14H
MAGNTA:	EQU	15H
CYAN:	EQU	16H
WHITE:	EQU	17H

P1COLR:	EQU	GREEN
P2COLR:	EQU	MAGNTA
PTCOLR:	EQU	RED

;	
MAXR:	EQU	0		;MAXIMUM RESOLUTION
MAXC:	EQU	1		;MAXIMUM COLOR CHOICE
R128:	EQU	2		;128 x 128 RESOLUTION
R64:	EQU	3		;64 x 64 COLOR RESOLUTION
R64BW:	EQU	4		;64 x 64 B/W RESOLUTION

INTLVS:	EQU	5		;START WITH 5 LIVES
;	
;	(THE	 FOLLOWING ASSUME THE 4MHZ. CPU CLOCK)
;	
SEC.:	EQU	10		;10 * 0.1SEC. = 1SEC.
TENTH:	EQU	SEC./10		;TENTH-SECOND PAUSE
QUARTR:	EQU	SEC./4		;QUARTER-SECOND PAUSE
HALF:	EQU	SEC./2		;HALF-SECOND PAUSE
ONE:	EQU	1*SEC.		;ONE SECOND PAUSE
TWO:	EQU	2*SEC.		;TWO SECONDS PAUSE
FOUR:	EQU	4*SEC.		;TWO SECONDS PAUSE
FIVE:	EQU	5*SEC.		;FIVE SECONDS PAUSE
TEN:	EQU	10*SEC.		;TEN SECONDS PAUSE
;
;	SOME OTHER REQUIRED VALUES
;
CR:	EQU	0DH		;CARRIAGE RETURN
LF:	EQU	0AH		;LINE FEED
CDOS:	EQU	5		;SYSTEM CALL LOCATION
WBOOT:	EQU	0		;WARM BOOT LOCATION
RDA:	EQU	40H		;RECEIVER-DATA-AVAILABLE

CSTATP:	EQU	0		;CONSOLE STATUS PORT (FOR CDOS BUILD)
CDATAP:	EQU	1		;CONSOLE DATA PORT (FOR CDOS BUILD)
CSTATB:	EQU	11		;BDOS CALL TO TEST FOR CONSOLE CHAR READY (FOR CP/M BUILD)
CDATAB:	EQU	6		;BDOS CALL TO GET CONSOLE CHAR DATA BYTE (FOR CP/M BUILD)

PNTBUF:	EQU	9		;PRINT BUFFERED LINE
PNTCHR:	EQU	2		;PRINT BUFFERED LINE
TOGDAZ:	EQU	7		;TOGGLE DAZZLER OFF/ON

JOY1UD:	EQU	1AH		;JOY STICK PORT - 1 UP/DOWN
JOY1RL:	EQU	19H		;JOY STICK PORT - 1 RIGHT/LEFT
JOY2UD:	EQU	1CH		;JOY STICK PORT - 2 UP/DOWN
JOY2RL:	EQU	1BH		;JOY STICK PORT - 2 RIGHT/LEFT
JOYBTN:	EQU	18H		;JOY STICK BUTTONS

SPEAK1:	EQU	19H		;SPEAKER 1
SPEAK2:	EQU	1BH		;SPEAKER 2

;	
;	GAME VALUES	
;	
PIXEL:  EQU	4		;PIXEL WIDTH IN 64x64 is 4 pixels since the library expects coords in 0-255
CTRLC:	EQU	3H		;CONTROL-C KEY CODE
PSKEY:	EQU	50H		;"P" KEY CODE

UP1:	EQU	57H		;"W" KEY CODE
DOWN1:	EQU	53H		;"A" KEY CODE
LEFT1:	EQU	41H		;"S" KEY CODE
RIGHT1:	EQU	44H		;"D" KEY CODE

UP2:	EQU	49H		;"I" KEY CODE
DOWN2:	EQU	4BH		;"K" KEY CODE
LEFT2:	EQU	4AH		;"J" KEY CODE
RIGHT2:	EQU	4CH		;"L" KEY CODE

STWAIT:	EQU	0		;WAITING FOR FIRST KEYPRESS
STMOVE:	EQU	1		;RUNNING

;
;	THE PROGRAM BEGINS HERE
;
SNAKE:	
	LD	SP,STACK	;SET STACK POINTER
	LD	DE,INTRO	;POINT TO SIGN-ON MESSAGE
	CALL	PRINTSTR	;DO SYSTEM CALL

	LD	SP,STACK	;DO IT AGAIN FOR SAFETY
	LD	HL,0		;TELLS INITG TO LOCATE PICTURE
				;  BUFFER AT TOP OF CDOS USER AREA

	CALL	GETJK		;GET JOYSTICK OR KEYBOARD CONTROL?
	CALL	GET12		;GET 1 OR 2 PLAYERS
	
	LD	A,(CNTRL)	;GET CONTROL MODE
	CP	'K'
	JR	NZ,SNAKE_1	

	LD	DE,INTKB1	;IF KEYBOARD, 
	CALL	PRINTSTR	;  DISPLAY HELP MESG
	
	LD	A,(MODE)
	CP	'2'
	JR	NZ,SNAKE_2	;IF 2 PLAYER,
	LD	DE,INTKB2	;  DISPLAY THEIR KEYS
	CALL	PRINTSTR

SNAKE_K:
	LD	DE,INTKB3	;DISPLAY SYSTEM KEYS
	CALL	PRINTSTR

	JR	SNAKE_2
SNAKE_1:
	CALL	INTJOY		;IF JOYSTICK, INIT 
	LD	DE,INTJS1	;  JOY STICKS AND
	CALL	PRINTSTR	;  DISPLAY HELP MSG
	LD	DE,INTJS2	;  AND SYSTEM BUTTONS
	CALL	PRINTSTR	;  
SNAKE_2:
	CALL	INITG		;INITIALIZE THE GRAPHICS PACKAGE
	LD	(MAXCD),HL	;STORE DISPLAY PARAMS. FOR FUTURE USE
	LD	A,R64		;SET SCREEN FOR COLOR
	CALL	CHAR		;  64 x 64 MODE

BEGIN:		
	LD	A,0
	LD	(POINT),A	;RESET THE POINT
	LD	(STAGE),A	;RESET THE STAGE
	LD	A,INTLVS	;SET INITIAL LIVES TO 5
	LD	(LIVES1),A
	LD	(LIVES2),A
	LD	A,56H
	LD	(RSEED),A 	;SET A RANDOM SEED low byte
	LD	A,4FH
	LD	(RSEED+1),A 	;SET A RANDOM SEED high byte
	;LD	A,0FFH		;SET INITIAL SPEED 255
	LD	A,0FAH		;SET INITIAL SPEED 250
	LD	(SPEED),A
	CALL	DISP_INTRO	;FLASH "DAZZLER SNAKE"
	CALL	DISP_STAGE	;FLASH THE CURRENT STAGE

;
; DRAW THE PLAYING FIELD
;
START:	
	CALL	NEWPOINT	;GENERATE A RANDOM X,Y FOR THE NEXT POINT & DISPLAY IT

; Begin Player 1 Init
	LD	A,4		;SET INITIAL SNAKE LENGTH
	LD	(SNKLN1),A
	LD	A,1		;SET INITIAL SNAKE DISPLAY LENGTH
	LD	(DSPLN1),A

	CALL 	RANDOM		;GENERATE A RANDOM NUMBER FOR X
	LD	H,A		;SET X = RANDOM
	LD	(HEADX1),A	;SET INITIAL SNAKE X POS
	LD	(BODYX1),A	;PUT SNAKE'S INITIAL HEAD X POSITION IN THE BODY ARRAY

	CALL 	RANDOM		;GENERATE A RANDOM NUMBER FOR X
	LD	L,A		;SET Y = RANDOM
	LD	(HEADY1),A	;SET INITIAL SNAKE Y POS
	LD	(BODYY1),A	;PUT SNAKE'S INITIAL HEAD Y POSITION IN THE BODY ARRAY

	LD	A,P1COLR	;DRAW THE SNAKE GREEN
	CALL	CHAR
	CALL	CURSOR		;MOVE CURSOR THERE
	CALL	DOT		;DRAW THE HEAD

	LD	A,0		;CLEAR THE INITIAL
	LD	(DIR1),A	;  MOVING DIRECTION
	LD	(NXDIR1),A	;  MOVING DIRECTION
	LD	A,STWAIT
	LD	(STAT1),A	;LOAD THE NEW STAGE & WAIT FOR KEYPRESS TO START
; End Player 1 Init

; Begin Player 2 Init
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	JR	NZ,EP2I		;IF NOT, SKIP THIS
	LD	A,4		;SET INITIAL SNAKE LENGTH
	LD	(SNKLN2),A
	LD	A,1		;SET INITIAL SNAKE DISPLAY LENGTH
	LD	(DSPLN2),A
	CALL 	RANDOM		;GENERATE A RANDOM NUMBER FOR X
	LD	H,A		;SET X = RANDOM
	LD	(HEADX2),A	;SET INITIAL SNAKE X POS
	LD	(BODYX2),A	;PUT SNAKE'S INITIAL HEAD X POSITION IN THE BODY ARRAY
	CALL 	RANDOM		;GENERATE A RANDOM NUMBER FOR X
	LD	L,A		;SET Y = RANDOM
	LD	(HEADY2),A	;SET INITIAL SNAKE Y POS
	LD	(BODYY2),A	;PUT SNAKE'S INITIAL HEAD Y POSITION IN THE BODY ARRAY
	
	LD	A,P2COLR	;DRAW THE SNAKE GREEN
	CALL	CHAR
	CALL	CURSOR		;MOVE CURSOR THERE
	CALL	DOT		;DRAW THE HEAD

	LD	A,0		;CLEAR THE INITIAL
	LD	(DIR2),A	;  MOVING DIRECTION
	LD	(NXDIR2),A	;  MOVING DIRECTION
	LD	A,STWAIT
	LD	(STAT2),A	;LOAD THE NEW STAGE & WAIT FOR KEYPRESS TO START
; End Player 2 Init
EP2I:
	CALL	DRAWLIVES
	CALL	DRAWPOINTS

;
; MAIN GAME LOOP
;
DRAW:
	CALL	DELAY		;DELAY & CHECK FOR CONTROL-CHARACTERS
	
; Begin Player 1 Snake Grow
	LD	A,(STAT1)	;CHECK TO SEE IF
	CP	STMOVE		;  WE'RE MOVING YET
	JR	NZ,BP2SG	;NO? WAIT FOR A KEYPRESS
	
	;FIRST, SEE IF I NEED TO ERASE THE TAIL?	
	LD	A,(SNKLN1)	;grab the current snake length
	LD	B,A		;put it in B for comparison
	LD	A,(DSPLN1)	;grab the currently displayed snake length
	;IF SNKLN < DSPLN
	CP	B
	JR	C,GROWSNK1	;if Display Length was < Snake Length
	LD	A,BLACK		;change color to BLACK
	CALL	CHAR
	LD	A,(BODYX1)
	LD	H,A		;SET X = A
	LD	A,(BODYY1)
	LD	L,A
	CALL 	CURSOR		;move the cursor to tail position
	CALL	DOT			;erase the tail
	
	;NOW SHIFT THE BODY X DATA IN MEMORY 1 BYTE TO THE LEFT
	LD	HL,BODYX1+1	; Load source address into HL
	LD	DE,TEMP		; Load destination address into DE
	LD	BC,0FEH		; Load byte count into BC
	LDIR

	LD	HL,TEMP		; Load source address into HL
	LD	DE,BODYX1	; Load destination address into DE
	LD	BC,0FFH		; Load byte count into BC
	LDIR

	;DO THE SAME FOR BODY Y
	LD	HL,BODYY1+1	; Load source address into HL
	LD	DE,TEMP		; Load destination address into DE
	LD	BC,0FEH		; Load byte count into BC
	LDIR

	LD	HL,TEMP		; Load source address into HL
	LD	DE,BODYY1	; Load destination address into DE
	LD	BC,0FFH		; Load byte count into BC
	LDIR
	
	JP BP2SG

GROWSNK1:
	;IF THE DSPLN < SNLKLEN THEN INCREMENT DSPLN
	LD	A,(DSPLN1)	;grab the currently displayed snake length
	INC	A		;increment it one A->current display len
	LD	(DSPLN1),A ;save
	
; End Player 1 Snake Grow

BP2SG:	
; Begin Player 2 Snake Grow
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	JR	NZ,EP2SG	;  IF NOT, SKIP THIS

	LD	A,(STAT2)	;CHECK TO SEE IF
	CP	STMOVE		;  WE'RE MOVING YET
	;JR	NZ,DRAW		;NO? WAIT FOR A KEYPRESS TODO: need to fix this
	JR	Z,P2MVG		; P2 is MOVING
	
	;if neither are moving yet, jump back to DRAW
	LD	A,(STAT1)	;CHECK TO SEE IF
	CP	STMOVE		;  WE'RE MOVING YET
	JP	NZ,DRAW		;NO? WAIT FOR A KEYPRESS
	JP	EP2SG
	
P2MVG:
	;FIRST, SEE IF I NEED TO ERASE THE TAIL?	
	LD	A,(SNKLN2)	;grab the current snake length
	LD	B,A		;put it in B for comparison
	LD	A,(DSPLN2)	;grab the currently displayed snake length
	;IF SNKLN < DSPLN
	CP	B
	JR	C,GROWSNK2	;if Display Length was < Snake Length
	LD	A,BLACK		;change color to BLACK
	CALL	CHAR
	LD	A,(BODYX2)
	LD	H,A		;SET X = A
	LD	A,(BODYY2)
	LD	L,A
	CALL 	CURSOR		;move the cursor to tail position
	CALL	DOT		;erase the tail
	
	;NOW SHIFT THE BODY X DATA IN MEMORY 1 BYTE TO THE LEFT
	LD	HL,BODYX2+1	;Load source address into HL
	LD	DE,TEMP		;Load destination address into DE
	LD	BC,0FEH		;Load byte count into BC
	LDIR
	LD	HL,TEMP		;Load source address into HL
	LD	DE,BODYX2	;Load destination address into DE
	LD	BC,0FFH		;Load byte count into BC
	LDIR
	;DO THE SAME FOR BODY Y
	LD	HL,BODYY2+1	;Load source address into HL
	LD	DE,TEMP		;Load destination address into DE
	LD	BC,0FEH		;Load byte count into BC
	LDIR
	LD	HL,TEMP		;Load source address into HL
	LD	DE,BODYY2	;Load destination address into DE
	LD	BC,0FFH		;Load byte count into BC
	LDIR
	
	JP EP2SG

GROWSNK2:
	;IF THE DSPLN < SNLKLEN THEN INCREMENT DSPLN
	LD	A,(DSPLN2)	;grab the currently displayed snake length
	INC	A		;increment it one A->current display len
	LD	(DSPLN2),A	;save
; End Player 2 Snake Grow
EP2SG:
; Begin Player 1 Movement & Collision Detection
	LD A,	P1COLR		;change color to GREEN for snake
	CALL	CHAR

	LD	A,(DIR1)	;WHICH DIRECTION ARE WE MOVING?
	CP	UP1		;MOVING UP?
	JR	Z,MVUP1		;DRAW THE NEXT PIXEL
	CP	DOWN1		;MOVING DOWN?
	JR	Z,MVDOWN1	;DRAW THE NEXT PIXEL
	CP	LEFT1		;MOVING LEFT?
	JR	Z,MVLEFT1	;DRAW THE NEXT PIXEL
	CP	RIGHT1		;MOVING RIGHT?
	JR	Z,MVRIGHT1	;DRAW THE NEXT PIXEL
	JP	BP2MCD		;PLAYER 1 must not be moving, check player 2
MVUP1:
	LD	A,(HEADY1)
	CP	240
	JP	Z,DIED1		;GAME OVER, HIT TOP OF FIELD
	ADD	A,PIXEL
	LD	(HEADY1),A
	JP	FINMV1
MVDOWN1:
	LD	A,(HEADY1)
	CP	12
	JP	Z,DIED1		;GAME OVER, HIT BOTTOM OF FIELD
	SUB	A,PIXEL
	LD	(HEADY1),A
	JP	FINMV1
MVLEFT1:
	LD	A,(HEADX1)
	CP	12
	JP	Z,DIED1		;GAME OVER, HIT LEFT OF FIELD
	SUB	A,PIXEL
	LD	(HEADX1),A
	JP	FINMV1
MVRIGHT1:
	LD	A,(HEADX1)
	CP	240
	JP	Z,DIED1		;GAME OVER, HIT RIGHT OF FIELD
	ADD	A,PIXEL
	LD	(HEADX1),A
FINMV1:
	;put the new coords at the end of the body	
	LD 	A,(HEADX1)
	LD	H,A		;SET X = A
	LD	A,(HEADY1)
	LD	L,A
	
	CALL 	CURSOR		;move the cursor to tail position
	CALL 	DOT		;DRAW LINE TO (HEADX,HEADY)

	LD	A,(DSPLN1)	;grab the currently displayed snake length
	DEC	A		;remove 1
	PUSH	AF		;save this offset value for later
	LD	DE,BODYX1	;grab the address of bodyx
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,H		;Put X in the accumulator
	LD	(DE),A		;save the new X position to the offset address

	POP	AF		;grab the offset again
	LD	DE,BODYY1	;grab the address of bodyx
	ADD	A,E		;add the offset	
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,L		;Put Y in the accumulator
	LD	(DE),A		;save the new Y position to the offset address

;
; COLLISION DETECTION - PLAYER 1 WITH POINT
;
	LD	A,(HEADX1)	;Need to compare HEADX = POINTX
	LD	B,A		;Move HEADX to B for comparison
	LD	A,(POINTX)	;Grab the POINT X
	CP	B		;COMPARE A(POINTX)=B(HEADX)
	JR	NZ,CB1_1_1	;IF not match, go to next step
	LD	A,(HEADY1)	;Need to compare HEADY = POINTY
	LD	B,A		;Move HEADY to B for comparison
	LD	A,(POINTY)	;Grab the POINT Y
	CP	B		;COMPARE A(POINTY)=B(HEADY)
	JR	NZ,CB1_1_1	;IF not match, go to next step
	; HIT THE POINT
	CALL	SONG1		;Play a tone
	LD	A,(POINT)	;grab the current point
	CP	9		;see if we're on point 10 (0-based)
	JP	Z,NEXTSTAGE	;  if so advance to next stage
	INC	A		;else increment the point
	LD	(POINT),A	;save the new point
	
				; INCREASE THE SNAKE SIZE
	LD	A,(SNKLN1)	; GRAB THE CURRENT LENGTH
	ADD	A,10 		; INCREASE THE SNAKE SIZE BY 10
	LD	(SNKLN1),A	; SAVE IT BACK
	CALL	NEWPOINT	; DRAW THE NEXT POINT
	CALL	DRAWPOINTS
	JP	BP2MCD

;
; COLLISION DETECTION - PLAYER 1 WITH SELF
;
CB1_1_1:
	LD	C,0		;START AT 0, USE AS OUR LOOP COUNTER
CB1_1_2:
	LD	A,(HEADX1)	;Need to compare HEADX = POINTX
	LD	B,A		;Move HEADX to B for comparison
	LD	DE,BODYX1	;grab the address of bodyx
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the X from the address offset
	CP	B		;COMPARE A(BODYX)=B(HEADX)
	JR	NZ,CB1_1_3 	;IF not match, go to next step
	LD	A,(HEADY1)	;Need to compare HEADY = POINTY
	LD	B,A		;Move HEADY to B for comparison
	LD	DE,BODYY1	;grab the address of body Y 
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the Y from the address offset
	CP	B		;COMPARE A(BODYY)=B(HEADY)
	JP	Z,CRASH1	;IF MATCH, SNAKE HIT ITSELF
	
CB1_1_3:
	LD	A,(DSPLN1)	;GET THE SNAKE'S DISPLAYED LENGTH
	DEC	A		;DON'T NEED TO COMPARE THE LAST ENTRY (HEAD)
	INC	C
	CP	C
	JP	Z,CB1_1_4	;WAS DRAW - IF WE HIT THE DISP LEN, KEEP LOOKING
	JP 	CB1_1_2		;ELSE, we're good - continue game loop	
; End Player 1 Movement & Collision Detection
CB1_1_4:
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	JP	NZ,DRAW		;  IF NOT, SKIP THIS

;
; COLLISION DETECTION - PLAYER 1 WITH PLAYER 2
;
CB1_2_1:
	LD	C,0		;START AT 0, USE AS OUR LOOP COUNTER	
CB1_2_2:
	LD	A,(HEADX1)	;Need to compare HEADX = POINTX
	LD	B,A		;Move HEADX to B for comparison
	LD	DE,BODYX2	;grab the address of bodyx
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the X from the address offset
	CP	B		;COMPARE A(BODYX)=B(HEADX)
	JR	NZ,CB1_2_3	;IF not match, go to next step
	LD	A,(HEADY1)	;Need to compare HEADY = POINTY
	LD	B,A		;Move HEADY to B for comparison
	LD	DE,BODYY2	;grab the address of body Y 
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the Y from the address offset
	CP	B		;COMPARE A(BODYY)=B(HEADY)
	JP	Z,CRASH2	;IF MATCH, SNAKE HIT ITSELF
	
CB1_2_3:
	LD	A,(DSPLN2)	;GET THE SNAKE'S DISPLAYED LENGTH
	INC	C
	CP	C
	JP	Z,BP2MCD	;WAS DRAW - IF WE HIT THE DISP LEN, KEEP LOOKING
	JP 	CB1_2_2		;ELSE, we're good - continue game loop	
; End Player 1 Movement & Collision Detection

BP2MCD:
;Begin Player 2 Movement & Collision Detection
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	JP	NZ,DRAW		;  IF NOT, SKIP THIS
	LD A,	P2COLR		;change color to MAGNTA for snake 2
	CALL	CHAR
	LD	A,(DIR2)	;WHICH DIRECTION ARE WE MOVING?
	CP	UP2		;MOVING UP?
	JR	Z,MVUP2		;DRAW THE NEXT PIXEL
	CP	DOWN2		;MOVING DOWN?
	JR	Z,MVDOWN2	;DRAW THE NEXT PIXEL
	CP	LEFT2		;MOVING LEFT?
	JR	Z,MVLEFT2	;DRAW THE NEXT PIXEL
	CP	RIGHT2		;MOVING RIGHT?
	JR	Z,MVRIGHT2	;DRAW THE NEXT PIXEL
	JP	DRAW		;Player 2 must not be moving
	
MVUP2:
	LD	A,(HEADY2)
	CP	240
	JP	Z,DIED2		;GAME OVER, HIT TOP OF FIELD
	ADD	A,PIXEL
	LD	(HEADY2),A
	JP	FINMV2
MVDOWN2:
	LD	A,(HEADY2)
	CP	12
	JP	Z,DIED2		;GAME OVER, HIT BOTTOM OF FIELD
	SUB	A,PIXEL
	LD	(HEADY2),A
	JP	FINMV2
MVLEFT2:
	LD	A,(HEADX2)
	CP	12
	JP	Z,DIED2		;GAME OVER, HIT LEFT OF FIELD
	SUB	A,PIXEL
	LD	(HEADX2),A
	JP	FINMV2
MVRIGHT2:
	LD	A,(HEADX2)
	CP	240
	JP	Z,DIED2		;GAME OVER, HIT RIGHT OF FIELD
	ADD	A,PIXEL
	LD	(HEADX2),A
FINMV2:
	;put the new coords at the end of the body	
	LD 	A,(HEADX2)
	LD	H,A		;SET X = A
	LD	A,(HEADY2)
	LD	L,A
	CALL 	CURSOR		;move the cursor to tail position
	CALL 	DOT		;DRAW LINE TO (HEADX,HEADY)
	LD	A,(DSPLN2)	;grab the currently displayed snake length
	DEC	A		;remove 1
	PUSH	AF		;save this offset value for later
	LD	DE,BODYX2	;grab the address of bodyx
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,H		;Put X in the accumulator
	LD	(DE),A		;save the new X position to the offset address

	POP	AF		;grab the offset again
	LD	DE,BODYY2	;grab the address of bodyx
	ADD	A,E		;add the offset	
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,L		;Put Y in the accumulator
	LD	(DE),A		;save the new Y position to the offset address

	;
	; COLLISION DETECTION - PLAYER 2 WITH POINT
	;
	LD	A,(HEADX2)	;Need to compare HEADX = POINTX
	LD	B,A		;Move HEADX to B for comparison

	LD	A,(POINTX)	;Grab the POINT X
	CP	B		;COMPARE A(POINTX)=B(HEADX)
	JR	NZ,CB2_2_1	;IF not match, go to next step

	LD	A,(HEADY2)	;Need to compare HEADY = POINTY
	LD	B,A		;Move HEADY to B for comparison
	LD	A,(POINTY)	;Grab the POINT Y
	CP	B		;COMPARE A(POINTY)=B(HEADY)
	JR	NZ,CB2_2_1	;IF not match, go to next step
	; HIT THE POINT
	CALL	SONG2		;Play a tone
	LD	A,(POINT)	;grab the current point
	CP	9		;see if we're on point 10 (0-based)
	JP	Z,NEXTSTAGE	;  if so advance to next stage
	INC	A		;else increment the point
	LD	(POINT),A	;save the new point

	; INCREASE THE SNAKE SIZE
	LD	A,(SNKLN2)	; GRAB THE CURRENT LENGTH
	ADD	A,10 		; INCREASE THE SNAKE SIZE BY 10
	LD	(SNKLN2),A	; SAVE IT BACK

	CALL	NEWPOINT	; DRAW THE NEXT POINT
	CALL	DRAWPOINTS
	JP	DRAW

	;
	; COLLISION DETECTION - PLAYER 2 WITH SELF
	;
CB2_2_1:
	LD	C,0		;START AT 0, USE AS OUR LOOP COUNTER
	
CB2_2_2:
	LD	A,(HEADX2)	;Need to compare HEADX = POINTX
	LD	B,A			;Move HEADX to B for comparison

	LD	DE,BODYX2	;grab the address of bodyx
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the X from the address offset

	CP	B		;COMPARE A(BODYX)=B(HEADX)
	JR	NZ,CB2_2_3	;IF not match, go to next step

	LD	A,(HEADY2)	;Need to compare HEADY = POINTY
	LD	B,A		;Move HEADY to B for comparison
	
	LD	DE,BODYY2	;grab the address of body Y 
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the Y from the address offset
	
	CP	B		;COMPARE A(BODYY)=B(HEADY)
	JP	Z,CRASH3	;IF MATCH, SNAKE HIT ITSELF
	
CB2_2_3:
	LD	A,(DSPLN2)	;GET THE SNAKE'S DISPLAYED LENGTH
	DEC	A		;DON'T NEED TO COMPARE THE LAST ENTRY (HEAD)
	INC	C
	CP	C
	JP	Z,CB2_1_1	;IF WE HIT THE DISP LEN, KEEP LOOKING
	JP 	CB2_2_2		;ELSE, we're good - continue game loop	

	;
	; COLLISION DETECTION - PLAYER 2 WITH PLAYER 1
	;
CB2_1_1:
	LD	C,0			;START AT 0, USE AS OUR LOOP COUNTER
	
CB2_1_2:
	LD	A,(HEADX2)	;Need to compare HEADX = POINTX
	LD	B,A		;Move HEADX to B for comparison

	LD	DE,BODYX1	;grab the address of bodyx
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the X from the address offset

	CP	B		;COMPARE A(BODYX)=B(HEADX)
	JR	NZ,CB2_1_3	;IF not match, go to next step

	LD	A,(HEADY2)	;Need to compare HEADY = POINTY
	LD	B,A		;Move HEADY to B for comparison
	
	LD	DE,BODYY1	;grab the address of body Y 
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the Y from the address offset
	
	CP	B		;COMPARE A(BODYY)=B(HEADY)
	JP	Z,CRASH4	;IF MATCH, SNAKE HIT ITSELF
	
CB2_1_3:
	LD	A,(DSPLN1)	;GET THE SNAKE'S DISPLAYED LENGTH
	INC	C
	CP	C
	JP	Z,DRAW		;IF WE HIT THE DISP LEN, KEEP LOOKING
	JP 	CB2_1_2		;ELSE, we're good - continue game loop	
;End Player 2 Movement & Collision Detection

CRASH1:
	;LD	E,'1' ;DEBUG PRINT
	;CALL	PRINTCHR 
	JP	DIED1
CRASH2:
	;LD	E,'2' ;DEBUG PRINT
	;CALL	PRINTCHR 
	JP	DIED1
CRASH3:
	;LD	E,'3' ;DEBUG PRINT
	;CALL	PRINTCHR 
	JP	DIED2
CRASH4:
	;LD 	E,'4' ;DEBUG PRINT
	;CALL	PRINTCHR 
	JP	DIED2

NEXTSTAGE:
	;INCREASE THE SPEED 
	LD	A,0		;RESET THE POINT
	LD	(POINT),A	;RESET THE POINT

	LD	A,(STAGE)	;grab the current stage
	INC	A		;increment the stage
	LD	(STAGE),A	;save the new stage
	
	;LD	DE,STGMSG	;PRINT
	;CALL	PRINTSTR	;  "STAGE: "
	;CALL	PRINTBYTE	;PRINT THE STAGE BYTE
	;LD	DE,CRLF		;PRINT NEWLINE
	;CALL	PRINTSTR

	LD	A,(SPEED)
	;SUB	0FH
	;SUB	019H
	SUB	1EH
	LD	(SPEED),A
	
	CALL	DISP_STAGE	;FLASH THE CURRENT STAGE
	
	JP	START
	
DIED1:
	LD	B,10		;FLASH THE SCREEN BY QUICKLY SWAPPING
FL_LOOP1:			;  BETWEEN B&W AND COLOR
	;LD	A,TENTH
	;CALL 	PAUSE
	PUSH 	AF
	PUSH	BC
	PUSH	DE
	CALL	SONG3		;PLAY TONE
	POP	DE
	POP	BC
	POP	AF

	LD	A,R64BW		;SET SCREEN FOR BW
	CALL	CHAR		;  64 x 64 MODE
	;LD	A,TENTH
	;CALL 	PAUSE	

	PUSH 	AF
	PUSH	BC
	PUSH	DE
	CALL	SONG3		;PLAY TONE
	POP	DE
	POP	BC
	POP	AF

	LD	A,R64		;SET SCREEN FOR COLOR
	CALL	CHAR		;  64 x 64 MODE
	DEC	B

	JR	NZ,FL_LOOP1

	LD	A,(LIVES1)	;DECREMENT LIVES
	DEC	A		;SUBTRACT THIS LIFE
	LD	(LIVES1),A	;SAVE IT BACK
	
	JR	Z,GAMEOVER	;LIVES HIT ZERO

	;USED A LIFE, RESET THE STAGE AT FIRST POINT
	LD	A,0		;RESET THE POINT
	LD	(POINT),A	;RESET THE POINT
	
	CALL	DISP_LIVES	;DISPLAY THE LIVES REMAINING

	JP	START

DIED2:
	LD	B,10		;FLASH THE SCREEN BY QUICKLY SWAPPING
FL_LOOP2:			;  BETWEEN B&W AND COLOR
	;LD	A,TENTH
	;CALL 	PAUSE
	PUSH 	AF
	PUSH	BC
	PUSH	DE
	CALL	SONG3		;PLAY TONE
	POP	DE
	POP	BC
	POP	AF

	LD	A,R64BW		;SET SCREEN FOR BW
	CALL	CHAR		;  64 x 64 MODE
	;LD	A,TENTH
	;CALL 	PAUSE	

	PUSH 	AF
	PUSH	BC
	PUSH	DE
	CALL	SONG3		;PLAY TONE
	POP	DE
	POP	BC
	POP	AF

	LD	A,R64		;SET SCREEN FOR COLOR
	CALL	CHAR		;  64 x 64 MODE
	
	DEC	B

	JR	NZ,FL_LOOP2

	LD	A,(LIVES2)	;DECREMENT LIVES
	DEC	A		;SUBTRACT THIS LIFE
	LD	(LIVES2),A	;SAVE IT BACK
	
	JR	Z,GAMEOVER	;LIVES HIT ZERO

	;USED A LIFE, RESET THE STAGE AT FIRST POINT
	LD	A,0			;RESET THE POINT
	LD	(POINT),A	;RESET THE POINT
	
	CALL	DISP_LIVES	;DISPLAY THE LIVES REMAINING

	JP	START

GAMEOVER:
	CALL	DISP_OVER
	JP	BEGIN		;RESTART THE GAME
	
WONGAME:
	LD	DE,WONMSG	;POINT TO GAME-WON MESSAGE
	CALL	PRINTSTR	;DO SYSTEM CALL
	LD	A,TOGDAZ	;SPECIAL CONTROL CHARACTER
	CALL	CHAR		;  TO TURN OFF/ON DAZZLER
	JP	WBOOT		;RETURN TO CDOS

NEWPOINT:	
	LD	A,PTCOLR	;GENERATE A RANDOM POINT
	CALL	CHAR		
NP2:
	CALL 	RANDOM		;GENERATE A RANDOM NUMBER FOR X
	LD	(POINTX),A	;STORE IT IN OUR POINTX VARIABLE
	LD	H,A		;  AND SET IT FOR "DOT"
	
	CALL 	RANDOM		;GENERATE A RANDOM NUMBER FOR Y
	LD	(POINTY),A	;STORE IT IN OUR POINTY VARIABLE
	LD	L,A		;  AND SET IT FOR "DOT"

;MAKE SURE THE NEW POINT DOESN'T 
;END UP DIRECTLY ON TOP OF PLAYER 1 SNAKE
NPCP1_1:
	LD	C,0		;START AT 0, USE AS OUR LOOP COUNTER
	
NPCP1_2:
	LD	A,(POINTX)	;Need to compare BODYX = POINTX
	LD	B,A		;Move POINTX to B for comparison

	LD	DE,BODYX1	;grab the address of bodyx
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the X from the address offset

	CP	B		;COMPARE A(BODYX)=B(HEADX)
	JR	NZ,NPCP1_3	;IF not match, go to next step

	LD	A,(POINTY)	;Need to compare BODYY = POINTY
	LD	B,A		;Move POINTY to B for comparison
	
	LD	DE,BODYY1	;grab the address of body Y 
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the Y from the address offset
	
	CP	B		;COMPARE A(BODYY)=B(HEADY)
	JP	Z,NP2		;IF MATCH, NEED TO GENERATE A NEW POINT
	
NPCP1_3:
	LD	A,(DSPLN1)	;GET THE SNAKE'S DISPLAYED LENGTH
	INC	C
	CP	C
	JP	Z,NPCP2_1	;IF WE HIT THE DISP LEN, continue
	JP 	NPCP1_2		;ELSE, keep looking

;make sure new point doesn't end up on top of player 2
NPCP2_1:
	;check if we're in 2 player mode
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	JR	NZ,NPFIN	;  IF NOT, SKIP THIS	

	LD	C,0		;START AT 0, USE AS OUR LOOP COUNTER

NPCP2_2:
	LD	A,(POINTX)	;Need to compare BODYX = POINTX
	LD	B,A		;Move POINTX to B for comparison

	LD	DE,BODYX2	;grab the address of bodyx
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the X from the address offset

	CP	B		;COMPARE A(BODYX)=B(HEADX)
	JR	NZ,NPCP2_3	;IF not match, go to next step

	LD	A,(POINTY)	;Need to compare BODYY = POINTY
	LD	B,A		;Move POINTY to B for comparison
	
	LD	DE,BODYY2	;grab the address of body Y 
	LD	A,C
	ADD	A,E		;add the offset
	LD	E,A
	LD	A,D
	ADC	A,0
	LD	D,A
	LD	A,(DE)		;grab the Y from the address offset
	
	CP	B		;COMPARE A(BODYY)=B(HEADY)
	JP	Z,NP2		;IF MATCH, NEED TO GENERATE A NEW POINT
	
NPCP2_3:
	LD	A,(DSPLN2)	;GET THE SNAKE'S DISPLAYED LENGTH
	INC	C
	CP	C
	JP	Z,NPFIN		;IF WE HIT THE DISP LEN, continue
	JP 	NPCP2_2		;ELSE, keep looking
	
NPFIN:
	CALL	CURSOR		;MOVE CURSOR TO POINT
	CALL	DOT		;  AND DISPLAY IT
	RET
	
;
; UTILITY FUNCTIONS
;


;DRAW WHITE BORDER AROUND THE SCREEN
BORDER:
	CALL	PAGE		;CLEAR THE SCREEN
	LD	A,WHITE		;SET BORDER LINE
	CALL	CHAR		;  COLOR TO WHITE

	LD	H,0		;SET X = 0
	LD	L,0		;SET Y = 0
	CALL	CURSOR		;MOVE CURSOR THERE
	LD	H,8		;SET X = 0
	LD	L,255		;SET Y = 0
	CALL	AREA		;MOVE CURSOR THERE
	LD	H,255		;SET X = 0
	LD	L,247		;SET Y = 0
	CALL	AREA		;MOVE CURSOR THERE
	LD	H,247		;SET X = 0
	LD	L,0		;SET Y = 0
	CALL	AREA		;MOVE CURSOR THERE
	LD	H,8		;SET X = 0
	LD	L,8		;SET Y = 0
	CALL	AREA		;MOVE CURSOR THERE
	RET

DRAWLIVES:
	;draw how many Player 1 lives are left with green dots in the upper-left corner
	LD	A,(LIVES1)
	LD	B,A
	
	LD	H,4		;SET X = 0
	LD	L,251		;SET Y = 0
	CALL	CURSOR		;MOVE CURSOR THERE
	LD	A,P1COLR
	CALL	CHAR
LV_LOOP1:
	LD	A,H
	ADD	A,8
	LD	H,A
	CALL	CURSOR
	CALL	DOT

	DEC	B
	JR	NZ,LV_LOOP1

	;Draw Player 2 lives too?
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	RET	NZ		;  IF NOT, SKIP THIS	

	LD	A,(LIVES2)
	LD	B,A
	
	LD	H,4		;SET X = 0
	LD	L,4		;SET Y = 0
	CALL	CURSOR		;MOVE CURSOR THERE
	LD	A,P2COLR
	CALL	CHAR
LV_LOOP2:
	LD	A,H
	ADD	A,8
	LD	H,A
	CALL	CURSOR
	CALL	DOT

	DEC	B
	JR	NZ,LV_LOOP2
	
	RET

DRAWPOINTS:
	;draw how many POINTS are left in the stage with red dots in the upper-right corner

	LD	A,WHITE		;CLEAR OUT THE LINE OF POINTS FIRST
	CALL	CHAR
	LD	H,251		;SET X = 0
	LD	L,251		;SET Y = 0
	CALL	CURSOR		;MOVE CURSOR THERE
	LD	H,171		;SET X = 0
	LD	L,251		;SET Y = 0
	CALL	LINE		;MOVE CURSOR THERE
		
	LD	A,(POINT)
	LD	B,A
	LD	A,10
	SUB	B		;A now has how many points to print (10-POINTS)
	LD	B,A		;COPY to B
	
	LD	H,251		;SET X = 0
	LD	L,251		;SET Y = 0
	CALL	CURSOR		;MOVE CURSOR THERE
	LD	A,PTCOLR
	CALL	CHAR
PT_LOOP:
	LD	A,H
	SUB	8		;PIXEL*2
	LD	H,A
	CALL	CURSOR
	CALL	DOT
	
	DEC	B
	JR	NZ,PT_LOOP
	RET	
	
;
;FLASHING INTRO SCREEN
;
DISP_INTRO:
	CALL	PAGE
	CALL	BORDER
	LD	HL,389AH	;POSITION CURSOR PRIOR
	CALL	CURSOR		;  TO WRITING LOGO
	LD	A,WHITE		;draw the snake in color
	CALL	CHAR
	LD	HL,DAZSTR	;WRITE "DAZZLER"
	CALL	STRING
	
	LD	HL,4C7AH	;POINT TO START
	CALL	CURSOR		;  OF NEXT WORD
	LD	HL,SNKSTR	;WRITE THE WORD
	CALL	STRING		;  "SNAKE"
	
	LD	HL,6064H	;POINT TO START
	CALL	CURSOR		;  OF NEXT WORD
	LD	HL,BYARON	;WRITE
	CALL	STRING		;  "By Aron Hoekstra"

	CALL	CYCLE		;CYCLE ALL THE COLORS
	CALL	CONINP		;CALL CONINP NOW TO CLEAR THE INPUT BUFFER
	
	RET

;
;FLASHING STAGE SCREEN
;
DISP_STAGE:
	CALL	PAGE
	CALL	BORDER
	LD	HL,2D7AH	;MOVE CURSOR
	CALL	CURSOR		;  TO CENTER
	LD	HL,STGSTR	;WRITE THE WORD
	CALL	STRING		;  "STAGE"

	LD	HL,0AC7AH	;MOVE CURSOR
	CALL	CURSOR		;  OVER A BIT
	
	LD	A,(STAGE)	;GRAB THE STAGE VALUE
	INC	A		;ADD 1 FOR DISPLAY
	CALL	DISPBYTE	;DISPLAY THE NUMBER

	CALL	CYCLE		;CYCLE ALL THE COLORS

	CALL	PAGE
	CALL	BORDER
	CALL	CONINP		;CALL CONINP NOW TO CLEAR THE INPUT BUFFER

	RET

;
;DISPLAY REMAINING LIVES
;
DISP_LIVES:
	CALL	PAGE
	CALL	BORDER
	
	;Player 1 Lives
	LD	HL,1BAAH	;MOVE CURSOR
	CALL	CURSOR		;  TO CENTER
	LD	HL,LV1STR	;WRITE THE WORD
	CALL	STRING		;  "P1 LIVES"

	LD	HL,0C4AAH	;MOVE CURSOR
	CALL	CURSOR		;  OVER A BIT
	
	LD	A,(LIVES1)	;GRAB THE STAGE VALUE
	CALL	DISPBYTE	;DISPLAY THE NUMBER

	;Player 2 Lives
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	JR	NZ,DSLV2	;IF NOT, SKIP THIS

	LD	HL,1B3EH	;MOVE CURSOR
	CALL	CURSOR		;  TO CENTER
	LD	HL,LV2STR	;WRITE THE WORD
	CALL	STRING		;  "P2 LIVES"

	LD	HL,0C43EH	;MOVE CURSOR
	CALL	CURSOR		;  OVER A BIT
	
	LD	A,(LIVES2)	;GRAB THE STAGE VALUE
	CALL	DISPBYTE	;DISPLAY THE NUMBER

DSLV2:
	LD	A,TWO
	CALL 	PAUSE

	CALL	PAGE
	CALL	BORDER
	CALL	CONINP		;CALL CONINP NOW TO CLEAR THE INPUT BUFFER

	RET

;
;DISPLAY GAME OVER
;
DISP_OVER:
	CALL	PAGE
	CALL	BORDER
	
	LD	HL,107AH	;MOVE CURSOR
	CALL	CURSOR		;  TO CENTER
	LD	HL,GOVSTR	;WRITE THE WORDS
	CALL	STRING		;  "GAME OVER"

	LD	A,FOUR
	CALL 	PAUSE

	CALL	PAGE
	CALL	BORDER
	CALL	CONINP		;CALL CONINP NOW TO CLEAR THE INPUT BUFFER

	RET

;
;GET CONSOLE INPUT J OR K
;
GETJK:
	LD	DE,INTJK	;GET JOYSTICK OR KEYBOARD
	CALL	PRINTSTR	;DO SYSTEM CALL
GETJK1:	
	CALL	CONSTAT		;GET CONSOLE STATUS	
	JR	Z,GETJK1	;RETURN TO MAIN PROGRAM
	CALL	GETDATA		;CHECK THE CHARACTER

	CP	'J'		;CHECK FOR UP KEY
	JR	Z,GETJK2	;PROCESS THE KEYPRESS
	CP	'j'		;Lower-Case?
	JR	Z,GETJKLC	;PROCESS THE KEYPRESS
		
	CP	'K'		;CHECK FOR DOWN KEY
	JR	Z,GETJK2	;PROCESS THE KEYPRESS
	CP	'k'		;Lower-Case?
	JR	Z,GETJKLC	;PROCESS THE KEYPRESS

	JR	GETJK1		;Invalid key, keep waiting
GETJKLC:
	SUB	A,20H		;CONVERT TO UPPER-CASE
GETJK2:	
	LD	(CNTRL),A	;SAVE THE CONTROL METHOD
	LD 	E,A		;ECHO THE KEY
	CALL 	PRINTCHR 	;  BACK TO CONSOLE
	LD	DE,CRLF		;CRLF
	CALL	PRINTSTR	;DO SYSTEM CALL
	RET			;RETURN TO MAIN IF NEITHER

;
;GET CONSOLE INPUT 1 OR 2
;
GET12:
	LD	DE,INT12	;HOW MANY PLAYERS
	CALL	PRINTSTR	;DO SYSTEM CALL
GET12_1:	
	CALL	CONSTAT		;GET CONSOLE STATUS
	JR	Z,GET12_1	;RETURN TO MAIN PROGRAM
	CALL	GETDATA		;CHECK THE CHARACTER

	CP	'1'		;CHECK FOR UP KEY
	JR	Z,GET12_2	;PROCESS THE KEYPRESS

	CP	'2'		;CHECK FOR DOWN KEY
	JR	Z,GET12_2	;PROCESS THE KEYPRESS

	JR	GET12_1		;Invalid key, keep waiting
GET12_2:	
	LD	(MODE),A	;SAVE THE PLAYER MODE SELECTION
	LD 	E,A	   	;ECHO THE KEY
	CALL	PRINTCHR 	;  BACK TO CONSOLE
	LD	DE,CRLF		;CRLF
	CALL	PRINTSTR	;DO SYSTEM CALL
	CALL	PRINTSTR	;DO SYSTEM CALL
	RET			;RETURN TO MAIN IF NEITHER

GETDATA:
	IF CPM EQ 0
	IN	A,CDATAP	;GET THE CHARACTER
	AND	7FH		;STRIP PARITY BIT
	ENDIF
	IF CPM EQ 1
	PUSH	BC
	LD	C,CDATAB
	CALL	CDOS
	POP	BC
	ENDIF
	RET

;
;SUBROUTINE TO SAMPLE CONSOLE FOR CONTROL-CHARACTERS
;
CONINP:	
	LD	A,(CNTRL)	;GET CONTROL MODE
	CP	'K'
	JR	NZ,JOYCHK

;KEYBOARD INPUT CHECK
	CALL	CONSTAT		;GET CONSOLE STATUS (WAS THERE A KEY PRESSED IN THE INPUT BUFFER?)
	RET	Z		;RETURN TO MAIN PROGRAM
	CALL	CONDATA		;CHECK THE CHARACTER

	;PLAYER 1
	CP	UP1		;CHECK FOR UP KEY
	JP	Z,NXTPR1	;PROCESS THE KEYPRESS
	CP	UP1+20H		;Lower-Case?
	JP	Z,NXTPRLC1	;PROCESS THE KEYPRESS
		
	CP	DOWN1		;CHECK FOR DOWN KEY
	JP	Z,NXTPR1	;PROCESS THE KEYPRESS
	CP	DOWN1+20H	;Lower-Case?
	JP	Z,NXTPRLC1	;PROCESS THE KEYPRESS

	CP	LEFT1		;CHECK FOR LEFT KEY
	JP	Z,NXTPR1	;PROCESS THE KEYPRESS
	CP	LEFT1+20H	;Lower-Case?
	JP	Z,NXTPRLC1	;PROCESS THE KEYPRESS

	CP	RIGHT1		;CHECK FOR RIGHT KEY
	JP	Z,NXTPR1	;PROCESS THE KEYPRESS
	CP	RIGHT1+20H	;Lower-Case?
	JP	Z,NXTPRLC1	;PROCESS THE KEYPRESS
	
	;PLAYER 2
	CP	UP2		;CHECK FOR UP KEY
	JP	Z,NXTPR2	;PROCESS THE KEYPRESS
	CP	UP2+20H		;Lower-Case?
	JP	Z,NXTPRLC2	;PROCESS THE KEYPRESS
		
	CP	DOWN2		;CHECK FOR DOWN KEY
	JP	Z,NXTPR2	;PROCESS THE KEYPRESS
	CP	DOWN2+20H	;Lower-Case?
	JP	Z,NXTPRLC2	;PROCESS THE KEYPRESS

	CP	LEFT2		;CHECK FOR LEFT KEY
	JP	Z,NXTPR2	;PROCESS THE KEYPRESS
	CP	LEFT2+20H	;Lower-Case?
	JP	Z,NXTPRLC2	;PROCESS THE KEYPRESS

	CP	RIGHT2		;CHECK FOR RIGHT KEY
	JP	Z,NXTPR2	;PROCESS THE KEYPRESS
	CP	RIGHT2+20H	;Lower-Case?
	JP	Z,NXTPRLC2	;PROCESS THE KEYPRESS
	
	;OTHER KEYS
	CP	PSKEY		;CHECK FOR PAUSE KEY
	RET	NZ		;RETURN TO MAIN IF NEITHER
	
JOYCHK:
	;READ JOYSTICK 1
	LD	A,(AJ1UD)	;GET ADJUSTMENT
	LD	B,A
	IN	A,JOY1UD    	;READ JOY STICK UP/DOWN 
	ADD	B		;ADJUST
	LD	B,A
	LD	A,(AJ1RL)	;GET ADJUSTMENT
	LD	C,A
	IN	A,JOY1RL	;READ RIGHT/LEFT 
	ADD	C		; ADJUST
	LD	C,A
	CALL	FDR1		;FIND DIRECTION
	AND	A
	JR	Z,JC1_B		;NO CHANGE - CHECK BUTTONS
	LD	(NXDIR1),A	;CHANGE DIRECTION

JC1_B:
	;READ BUTTONS
	IN	A,JOYBTN	;READ IN THE BUTTONS
	BIT 	0,A        	;SEE IF BIT 0 IS SET (JS1 - BUTTON 4)
	JR	Z,DAZOFF 	;  IF SO, EXIT GAME
	BIT	3,A		;SEE IF BIT 3 IS SET (JS1 - BUTTON 1)
	JR	NZ,JC2_2	;IF NOT CONTINUE WITH JOYSTICK 2	
JC1_1:				;  IF SET, PAUSE THE GAME
	IN 	A,JOYBTN	;WAIT FOR BUTTON TO BE RELEASED
	BIT	3,A		;CHECK BUTTON 1 NOW
	JR	Z,JC1_1		;CONTINUE WAITING
JC1_2:
	IN 	A,JOYBTN	;NOW WAIT FOR BUTTON TO BE PRESSED AGAIN
	BIT	3,A		;CHECK BUTTON 1 NOW
	JR	NZ,JC1_2	;CONTINUE WAITING
JC1_3:
	IN 	A,JOYBTN	;AND RELEASED AGAIN...
	BIT	3,A		;CHECK BUTTON 1 NOW
	JR	Z,JC1_3		;CONTINUE WAITING

JC2_2:
	;READ JOYSTICK 2
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	RET	NZ		;  IF NOT, EXIT
	
	LD	A,(AJ2UD)	;GET ADJUSTMENT
	LD	B,A
	IN	A,JOY2UD    	;READ JOY STICK UP/DOWN 
	ADD	B		;ADJUST
	LD	B,A
	LD	A,(AJ2RL)	;GET ADJUSTMENT
	LD	C,A
	IN	A,JOY2RL	;READ RIGHT/LEFT 
	ADD	C		; ADJUST
	LD	C,A
	CALL	FDR2		;FIND DIRECTION
	AND	A
	RET	Z
	;JR	Z,JC2_B		;NO CHANGE
	LD	(NXDIR2),A	;CHANGE DIRECTION
;JC2_B:
	;READ BUTTONS		disabling player 2 buttons for now
	;IN	A,JOYBTN	;READ IN THE BUTTONS
	;BIT 	7,A        	;SEE IF BIT 0 IS SET (JS2 - BUTTON 4)
	;JR	Z,DAZOFF 	;  IF SO, EXIT GAME
	
	RET

	
CONLOOP:
	CALL	CONSTAT		;PAUSED, LOOP CHECKING 
	JR	Z,CONLOOP	;FOR ANOTHER CHARACTER
CONDATA:
	CALL	GETDATA		;READ THE CHARACTER
	;IN	A,CDATA		;GET THE CHARACTER
	;AND	7FH		;STRIP PARITY BIT
	CP	CTRLC		;CHECK FOR CONTROL-C
	JR	Z,DAZOFF	;EXIT IF TRUE
	RET			;RETURN IF NEITHER
CONSTAT:
	IF CPM EQ 0
	IN	A,CSTATP	;GET CONSOLE STATUS
	AND	RDA		;CHECK RDA BIT
	ENDIF
	IF CPM EQ 1
	PUSH	BC
	LD	C,CSTATB	;CHECK CHAR READY
	CALL	CDOS		;DO SYSTEM CALL
	POP	BC
	CP	0		;A CONTAINS 0 IF NOTHING WAS PRESSED
	ENDIF
	RET			;RETURNS RESULT WITH Z

DAZOFF:	
	LD	A,TOGDAZ	;SPECIAL CONTROL CHARACTER
	CALL	CHAR		;  TO TURN OFF/ON DAZZLER
	JP	WBOOT		;RETURN TO CDOS

NXTPRLC1:
	SUB	A,20H		;CONVERT TO UPPER-CASE
NXTPR1:
	LD	(NXDIR1),A	;SAVE THE KEY PRESSED
	RET

NXTPRLC2:
	SUB	A,20H		;CONVERT TO UPPER-CASE
NXTPR2:
	LD	(NXDIR2),A	;SAVE THE KEY PRESSED
	RET

;FIND JOYSTICK DIRECTION - BORROWED FROM "GOTCHA"
;INPUT - B CONTAINS UP/DOWN
;        C CONTAINS RIGHT/LEFT 
;OUTPUT - A CONTAINS DIRECTION
;
FDR1:	LD	A,B	    	;GET UP/DOWN
	AND	A
	JP	M,FDR301   	;DOWN
	LD	D,UP1		;UPWARD
	JP	FDR321
;
FDR301:	LD	D,DOWN1		;DOWNWARD
	CPL			;COMPLIMENT
	LD	B,A		;SAVE COMPLIMENT
FDR321: CP	40H
	JP	NC,FDR331	;LARGE MOVEMENT
	LD	D,0		; NO CHANGE
FDR331: LD	A,C		;GET RIGHT/LEFT
	AND	A
	JP	M,FDR401	;LEFT
	LD	E,RIGHT1	;RIGHT
	JP	FDR421
;
FDR401: LD	E,LEFT1		;LEFT
	CPL			;COMPLIMENT
	LD	C,A		;SAVE COMPLIMENT
FDR421: CP	40H
	JP	NC,FDR431	;LARGE MOVEMENT
	LD	E,0		;NO CHANGE
FDR431: LD	A,D
	SUB	E
	RET	Z		;NO CHANGE
	LD	A,D
	AND	A
	JP	Z,FDR501	;MUST BE RIGHT/LEFT
	LD	A,E
	AND	A
	JP	Z,FDR551	;MUST BE UP/DOWN
	LD	A,B
	CP	C
	JP	C,FDR501	;MUST BE RIGHT/LEFT
FDR501: LD	A,E 
	RET
;
FDR551: LD	A, D
	RET	
	
;FIND JOYSTICK DIRECTION - PLAYER 2
;INPUT - B CONTAINS UP/DOWN
;        C CONTAINS RIGHT/LEFT 
;OUTPUT - A CONTAINS DIRECTION
;
FDR2:	LD	A,B	    	;GET UP/DOWN
	AND	A
	JP	M,FDR302   	;DOWN
	LD	D,UP2		;UPWARD
	JP	FDR322
;
FDR302:	LD	D,DOWN2		;DOWNWARD
	CPL			;COMPLIMENT
	LD	B,A		;SAVE COMPLIMENT
FDR322: CP	40H
	JP	NC,FDR332	;LARGE MOVEMENT
	LD	D,0		; NO CHANGE
FDR332: LD	A,C		;GET RIGHT/LEFT
	AND	A
	JP	M,FDR402	;LEFT
	LD	E,RIGHT2	;RIGHT
	JP	FDR422
;
FDR402: LD	E,LEFT2		;LEFT
	CPL			;COMPLIMENT
	LD	C,A		;SAVE COMPLIMENT
FDR422: CP	40H
	JP	NC,FDR432	;LARGE MOVEMENT
	LD	E,0		;NO CHANGE
FDR432: LD	A,D
	SUB	E
	RET	Z		;NO CHANGE
	LD	A,D
	AND	A
	JP	Z,FDR502	;MUST BE RIGHT/LEFT
	LD	A,E
	AND	A
	JP	Z,FDR552	;MUST BE UP/DOWN
	LD	A,B
	CP	C
	JP	C,FDR502	;MUST BE RIGHT/LEFT
FDR502: LD	A,E 
	RET
;
FDR552: LD	A, D
	RET	
	

DELAY:
	LD	A,(SPEED)
DELAY1:
	PUSH	AF
	CALL	DELAY2		;Call Function if no borrow (BC <= HL after subtraction)
	CALL	CONINP		;Check for input
	POP	AF

	SUB	05H		;SUBTRACT
	CP	0		;see if its zero
	JR	NZ,DELAY1	;loop
	
	CALL	CHKNXT		;validate keyboard input
	
	RET			;exit loop
	
;DELAY THE GAME LOOP FOR AN ADJUSTABLE AMOUNT OF TIME
;Based on Michael's answer at:
;https://stackoverflow.com/questions/29184900/z80-software-delay
DELAY2:	
	PUSH	AF
	PUSH	BC
	LD	BC,100		; Load BC with the number of cycles for delay
	NOP			; Optional NOP to align loop timing
DL_LOOP:
	DEC	BC		; Decrement BC
	LD	A, B		; Load A with high byte of BC
	OR	C		; Logical OR A with low byte of BC
	JR	NZ,DL_LOOP	; If BC is not zero, jump back to DELAY_LOOP
	POP	AF
	POP	BC
	RET			; Return from the delay function

;ROUTINE TO VALIDATE THE INPUT THAT WAS CAPTURED DURING
;THE DELAY LOOP - WE ONLY PROCESS THIS ONCE AT THE END
;OF THE DELAY IN CASE MULTIPLE KEYS WERE PRESSED, WE
;ONLY LOOK AT THE LAST KEY PRESSED
;
CHKNXT:
	LD	A,(DIR1)	;Get the current direction
	LD	B,A		;copy Current Direction to B	
	LD	A,(NXDIR1)	;Get buffered next move to A
	
	CP	B
	JR	Z,CHKNXT2	;no change, check player 2 input

;PLAYER 1
CHKNXT1U:
	CP	UP1		;was keypress up?
	JR	NZ,CHKNXT1D

	LD	C,A
	LD	A,B
	CP	DOWN1		;was the previous direction down?
	LD	A,C

	JR	Z,CHKNXT2	;it was, discard
	JR	CHKNXT1V

CHKNXT1D:
	CP	DOWN1		;was keypress up?
	JR	NZ,CHKNXT1L
	LD	C,A
	LD	A,B
	CP	UP1		;was the previous direction up?
	LD	A,C
	JR	Z,CHKNXT2	;it was, discard
	JR	CHKNXT1V
CHKNXT1L:
	CP	LEFT1		;was keypress left?
	JR	NZ,CHKNXT1R
	LD	C,A
	LD	A,B
	CP	RIGHT1		;was the previous direction right?
	LD	A,C
	JR	Z,CHKNXT2	;it was, discard
	JR	CHKNXT1V
CHKNXT1R:
	CP	RIGHT1		;was keypress right?
	JR	NZ,CHKNXT2
	LD	C,A
	LD	A,B
	CP	LEFT1		;was the previous direction left?
	LD	A,C
	JR	Z,CHKNXT2	;it was, discard
	JR	CHKNXT1V
CHKNXT1V:			;was a valid Move
	LD	(DIR1),A	;save the move
	LD	A,STMOVE	;GET US MOVING
	LD	(STAT1),A	;UPDATE STATUS
	
;PLAYER 2
CHKNXT2:
	LD	A,(MODE)	;GRAB THE GAME MODE
	CP	'2'		;SEE IF WE'RE in 2-PLAYER MODE
	RET	NZ		;  IF NOT, SKIP THIS	
	
	LD	A,(DIR2)	;Get the current direction
	LD	B,A		;copy Current Direction to B	
	LD	A,(NXDIR2)	;Get buffered next move to A
	
	CP	B
	RET	Z		;no change, return
	
CHKNXT2U:
	CP	UP2		;was keypress up?
	JR	NZ,CHKNXT2D
	LD	C,A
	LD	A,B
	CP	DOWN2		;was the previous direction down?
	LD	A,C
	RET	Z		;it was, discard
	JR	CHKNXT2V
CHKNXT2D:
	CP	DOWN2		;was keypress up?
	JR	NZ,CHKNXT2L
	LD	C,A
	LD	A,B
	CP	UP2		;was the previous direction up?
	LD	A,C
	RET	Z		;it was, discard
	JR	CHKNXT2V
CHKNXT2L:
	CP	LEFT2		;was keypress left?
	JR	NZ,CHKNXT2R
	LD	C,A
	LD	A,B
	CP	RIGHT2		;was the previous direction right?
	LD	A,C
	RET	Z		;it was, discard
	JR	CHKNXT2V
CHKNXT2R:
	CP	RIGHT2		;was keypress right?
	RET	NZ
	LD	C,A
	LD	A,B
	CP	LEFT2		;was the previous direction left?
	LD	A,C
	RET	Z		;it was, discard	
CHKNXT2V:			;was a valid Move
	LD	(DIR2),A	;save the move
	LD	A,STMOVE ;GET US MOVING
	LD	(STAT2),A	;UPDATE STATUS
	RET
	
PRINTCHR:	;PRINT A SINGLE CHARACTER TO THE CONSOLE, put character in E before calling
	PUSH	BC
	LD	C,PNTCHR	;PRINT-CHARACTER
	CALL	CDOS		;DO SYSTEM CALL
	POP	BC
	RET
PRINTSTR:	;PRINT A $-terminated string to the console, put address of string in DE before calling
	PUSH	BC
	LD	C,PNTBUF	;PRINT-BUFFERED-LINE
	CALL	CDOS		;DO SYSTEM CALL
	POP	BC
	RET

PRINTBYTE:
	PUSH 	AF
	PUSH	BC
	PUSH	DE
	LD	B, A		; Copy byte value from A to B (to preserve A)

	; Print high nibble (4 bits) as hexadecimal digit
	LD	A, B		; Load byte value from B back into A
	AND 	0F0H		; Mask out low nibble (keep high nibble)
	RRCA             	; Rotate right A (move high nibble to low nibble)
	RRCA             	; Rotate right A again
	RRCA            	; Rotate right A again (now high nibble is in low nibble)
	RRCA            	; Rotate right A once more to clear upper bits
	CALL	PRINTHEX	; Call subroutine to print hexadecimal digit in A

	; Print low nibble (4 bits) as hexadecimal digit
	LD	A, B		; Reload byte value from B into A
	AND	00FH		; Mask out high nibble (keep low nibble)
	CALL	PRINTHEX	; Call subroutine to print hexadecimal digit in A

	POP	DE
	POP	BC
	POP	AF
	RET		        ; Return from the routine

PRINTHEX:
	ADD	A, '0'		; Convert digit (0-9) to ASCII ('0'-'9' range)
	CP	'9' + 1		; Compare with ASCII '9' + 1 (check if digit is 10 or higher)
	JR	NC, HEX_LETTER 	; If digit is 10 or higher, proceed to handle letters (A-F)

	; Digit is in '0'-'9' range, directly print the character
	LD	E,A
	CALL	PRINTCHR	; Call subroutine to print character in A
	RET			; Return from PRINT_HEX_DIGIT

HEX_LETTER:
	ADD	A, 'A'-('9'+1)  ; Convert digit (10-15) to ASCII ('A'-'F' range)
	LD	E,A
	CALL	PRINTCHR  	; Call subroutine to print character in A
	RET              	; Return from PRINT_HEX_DIGIT
	
DISPBYTE:
	PUSH 	AF
	PUSH	BC
	PUSH	DE
	LD	B, A		; Copy byte value from A to B (to preserve A)

	; Print high nibble (4 bits) as hexadecimal digit
	LD	A, B		; Load byte value from B back into A
	AND	0F0H		; Mask out low nibble (keep high nibble)
	RRCA			; Rotate right A (move high nibble to low nibble)
	RRCA			; Rotate right A again
	RRCA			; Rotate right A again (now high nibble is in low nibble)
	RRCA			; Rotate right A once more to clear upper bits
	CALL DISPHEX		; Call subroutine to print hexadecimal digit in A

	; Print low nibble (4 bits) as hexadecimal digit
	LD A, B			; Reload byte value from B into A
	AND 00FH		; Mask out high nibble (keep low nibble)
	CALL DISPHEX		; Call subroutine to print hexadecimal digit in A

	POP	DE
	POP	BC
	POP	AF
	RET              	; Return from the routine

DISPHEX:
	ADD	A, '0'		; Convert digit (0-9) to ASCII ('0'-'9' range)
	CP	'9' + 1		; Compare with ASCII '9' + 1 (check if digit is 10 or higher)
	JR	NC, DISPLETR	; If digit is 10 or higher, proceed to handle letters (A-F)

	; Digit is in '0'-'9' range, directly print the character
	CALL	CHAR		; Call subroutine to print character in A
	RET              	; Return from PRINT_HEX_DIGIT

DISPLETR:
	ADD	A, 'A'-('9'+1)  ; Convert digit (10-15) to ASCII ('A'-'F' range)
	LD	A,H	
	ADD	A,20H		;move the cursor
	LD	H,A
	CALL	CURSOR
	CALL 	CHAR		; Call subroutine to print character in A
	RET			; Return from PRINT_HEX_DIGIT

;AUDIO CODE BORROWED FROM "GOTCHA" GAME
;PLAY A SONG
SONG1:	LD	HL,SONP1P
	JP	NOTES

SONG2:	LD	HL,SONP2P
	JP	NOTES

SONG3:	LD	HL,SONDIE
	JP	NOTES

SONP1P: DB	40H		;VOLUME
	DB	150		;FREQ. PARM 
	DW	50		;DURATION
	DB	0		;END OF TABLE

SONP2P: DB	40H		;VOLUME
	DB	200		;FREQ. PARM 
	DW	50		;DURATION
	DB	0		;END OF TABLE

SONDIE: DB	40H		;VOLUME
	DB	250		;FREQ. PARM 
	DW	40		;DURATION
	DB	0		;END OF TABLE

;
;NOTES
;THIS ROUTINE PLAYS THE NOTES POINTED TO BY HL. ;1ST BYTE = VOLUME
;2ND BYTE = FREG. PARM
;3RD BYTE = LOW BYTE OF DURATION
;4TH BYTE = HIGH BYTE OF DURATION
;
NOTES:	LD	A,(HL)		;GET VOLUME
	AND	A
	RET	Z		;END OF NOTES
	LD	B,A		;MOVE VOLUME TO B
	INC	HL
	LD	C,(HL)		;GET FREG. PARM
	INC	HL
	LD	E,(HL)		;GET DURATION LOW
	INC	HL
	LD	D,(HL)		;GET DURATION HIGH
	INC	HL
	CALL	TONE		;OUTPUT TONE
	JP	NOTES
;
;TONE ROUTINE
;INPUT - B CONTAINS VOLUME
;        C CONTAINS FREG. PARM
;        DE CONTAINS DURATION
;
TONE:
TON200: LD	A,B		;GET VOLUME
	CPL			;COMPLIMENT
	LD	B,A		;SAVE VOLUME
	OUT	SPEAK1,A	;OUTPUT TO SPEAKERS
	OUT	SPEAK2,A
	LD	A,C		;GET FREG. PARM
TON300: DEC	A		;DEC COUNTER
	JP	NZ,TON300	;WAIT LOOP
	DEC	DE		;COUNT DOWN
	LD	A,D
	OR	E
	JP	NZ,TON200	;NOT THRU
	RET	

;
;INITIALIZE JOY STICKS
;
INTJOY: IN	A,JOY1UD	;GET UP/DOWN JOY STICK 1
	CPL
	LD	(AJ1UD),A	;ADJUSTMENT
	IN	A,JOY1RL	;GET RIGHT/LEFT JOY STICK
	CPL
	LD	(AJ1RL),A	;ADJUSTMENT
	IN	A,JOY2UD	;GET UP/DOWN JOY STICK 2
	CPL
	LD	(AJ2UD),A	;ADJUSTMENT
	IN	A,JOY2RL	;GET RIGHT/LEFT JOY STICK
	CPL
	LD	(AJ2RL),A	;ADJUSTMENT
	RET

;based on Ion Random
;https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
;-----> Generate a random number
; output a=answer 0<=a<=255
; all registers are preserved except: af
;Modified to retry in number 3<= || >=251 to place point inside field (not on wall)
RANDOM:
	PUSH    HL
	PUSH    DE
ANOTHER:		
	LD      HL,(RSEED)
	LD      A,R
	LD      D,A
	LD      E,(HL)
	ADD     HL,DE
	ADD     A,L
	XOR     H
	LD      (RSEED),HL
	
	CP	3
	JR	C, ANOTHER	;it was less than 1, generate another
	CP	61			
	JR	C, GOODRAND	; A was less than than 251 (and >=4) so we are ok
	JP	ANOTHER 	; It was not less than, so must be >=251, generate another		
GOODRAND:
	SLA A			; Left shift A (A * 2)
	SLA A			; Left shift A again (A * 2 * 2 = A * 4)
	; A is now multiplied by 4
	POP	DE
	POP	HL
	RET
		
;
;STRING DEFINITIONS
;
;SCREEN MESSAGES
DAZSTR:	DM	'DAZZLER'
SNKSTR:	DM	'SNAKE'
STGSTR:	DM	'STAGE'
LV1STR:	DM	P1COLR,'P1 LIVES'
LV2STR:	DM	P2COLR,'P2 LIVES'
GOVSTR:	DM	RED,'GAME OVER :('
BYARON:	DM	R128,'By Aron Hoekstra',R64

;CONSOLE MESSAGES
INTRO:	DB	'DAZZLER SNAKE by Aron Hoekstra',CR,LF,'$'
INT12:	DB  	'HOW MANY PLAYERS? [1,2] $'
INTJK:	DB  	'JOYSTICK OR KEYBOARD CONTROL? [J,K] $'
INTKB1: DB	'PLAYER 1 (GREEN) USES [W,A,S,D] FOR DIRECTION',CR,LF,'$'
INTKB2: DB	'PLAYER 2 (MAGNTA) USES [I,J,K,L] FOR DIRECTION',CR,LF,'$'
INTKB3:	DB	'[P] TO PAUSE, [CTRL+C] TO QUIT$'
INTJS1:	DB	'USE JS-1 JOYSTICK(S) PLUGGED INTO D+7A FOR CONTROL',CR,LF,'$'
INTJS2:	DB	'[BUTTON 1] TO PAUSE, [BUTTON 4] TO QUIT$'
WONMSG:	DB	CR,LF,'YOU WON!!??! CONGRATS!$'
CRLF:	DB	CR,LF,'$'

;
;VARIABLE STORAGE AREA
;
MAXCD:	DEFS	1	;MAXC DISPLAY DESCRIPTOR
MAXRD:	DEFS	1	;MAXR DISPLAY DESCRIPTOR

;GAME VARIABLES
POINTX:	DEFS	1	;CURRENT POINT X POS
POINTY:	DEFS	1	;CURRENT POINT Y POS
RSEED:	DEFS	2	;RANDOM NUMBER GENERATOR SEED
SPEED:	DEFS	2	;SPEED, for DELAY function, start at 6000, subtract 250 each stage for about 20 playable stages - 1000 starts getting really fast
STAGE:	DEFS	1	;WHICH STAGE YOU'RE ON, 6000 / 250 = 24 STAGES
MODE:	DEFS	1	;[1] OR [2] PLAYER GAME?
CNTRL:	DEFS	1	;[J]oystick or [K]eyboard control?
POINT:	DEFS	1	;WHICH POINT YOU'RE ON, 10 POINTS PER STAGE

;SNAKE VARIABLES
DIR1:	DEFS	1	;CURRENT SNAKE DIRECTION
NXDIR1:	DEFS	1	;BUFFER FOR NEXT SNAKE DIRECTION
HEADX1:	DEFS    1	;CURRENT SNAKE HEAD X POS
HEADY1:	DEFS	1	;CURRENT SNAKE HEAD Y POS
SNKLN1:	DEFS	1	;CURRENT SNAKE LENGTH (how long the snake is supposed to be)
DSPLN1:	DEFS	1	;DISPLAYED SNAKE LENGTH (how long is it currently displayed)
LIVES1:	DEFS	1	;HOW MANY LIVES ARE LEFT?
STAT1:	DEFS	1	;STATUS PLAYER 1 MOVING OR WAIT

DIR2:	DEFS	1	;CURRENT SNAKE DIRECTION
NXDIR2:	DEFS	1	;BUFFER FOR NEXT SNAKE DIRECTION
HEADX2:	DEFS    1	;CURRENT SNAKE HEAD X POS
HEADY2:	DEFS	1	;CURRENT SNAKE HEAD Y POS
SNKLN2:	DEFS	1	;CURRENT SNAKE LENGTH (how long the snake is supposed to be)
DSPLN2:	DEFS	1	;DISPLAYED SNAKE LENGTH (how long is it currently displayed)
LIVES2:	DEFS	1	;HOW MANY LIVES ARE LEFT?
STAT2:	DEFS	1	;STATUS PLAYER 2 MOVING OR WAIT

AJ1UD:	DEFS	1	;ADJUSTMENT FOR JOY1UD
AJ1RL:	DEFS	1	;ADJUSTMENT FOR JOY1RL
AJ2UD:	DEFS	1	;ADJUSTMENT FOR JOY2UD
AJ2RL:	DEFS	1	;ADJUSTMENT FOR JOY2RL

;	ORG 04000H
BODYX1:	DS	256	;X BODY POSITIONS FOR PLAYER 1
BODYY1:	DS	256	;Y BODY POSITIONS FOR PLAYER 1
BODYX2:	DS	256	;X BODY POSITIONS FOR PLAYER 2
BODYY2:	DS	256	;Y BODY POSITIONS FOR PLAYER 2
TEMP:	DS	256	;BODY TEMP COPY AREA (It's not recommended to use LDIR if the memory addresses overlap - so we temporarily write here, then write back - not sure if this is totally necessary)
STACK:	EQU	$
	END	SNAKE
